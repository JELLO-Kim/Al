# 구현 ?
> "이코테" 에서는 **완전탐색**과 **시뮬레이션 유형**을 모두 "구현" 유형으로 묶어서 다룬다.

- **완전 탐색** : 모든 경우의 수를 다 계산하는 방법
- **시뮬레이션** : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 방법

<br>
<br>

# 메모리 제약 사항 고려하기

<br>

## 자료형(정수)
언어의 종류에 따라 자료형을 사용하는데 고려해야할때가 있다. 예를들어 `파이썬`의 경우 정수형의 변수를 선언하는데 해당 변수의 "자료형"을 선언하지 않는다. 지정된 값에 따라 팓이썬에서 자동으로 지정되기 때문.
하지만 `자바 / C / C++`의 경우 **변수를 선언하는데 자료형을 지정해 주어야 한다.** 이때, 정수형의 자료형으로는 다음과 같이 있다.
>
- int : 4byte / -2,147,483,648 ~ 2,147,483,648
- long long : 8byte / -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,808
- BigInteger(클래스) : 가변적 / 제약없음

<br>

## List 크기 (python)
변수의 자료형을 미리 지정해주지 않는 python이지만 list 사용시 그 길이에 다라 메모리 사용량이 소모된다.
>
- 1,000 : 약 4KB
- 1,000,000 : 약 4MB
- 10,000,000 : 약 40MB

입출력 속도까지 고려하여 시간제한을 설정하는 것은 매우 까다로우므로 애초에 문제에서 주어진 메모리 사용량 제한 보다 **더 적은 크기의 메모리를 사용하도록**하면서 코드를 작성해야 한다.

<br>

> ### Python VS C/C++
- python은 C/C++에 비해 동작 속도가 느리다. (속도효율 : python < C>)
- C/C++나 Java에서는 문자열 처리가 python에 비해 까다롭고, 큰 정수를 처리하는 라이브러리를 별도로 사용해야 한다. (구현난이도 효율 : python > C)

<br>

# 문제 예제

<br>

## 1. 상하좌우
>
L / R / U / D : 좌 / 우 / 상 / 하
- 시작은 항상 (1, 1) (행, 열)
- 주어진 이동 후 최종 위치를 구하자
- 주어진 배열을 벗어나는 경우는 없다
- 결과 좌표는 공백으로 구분하여 출력한다


##### Sol1 : 일반적 풀이 (4가지 방향에 대한 조건문 사용)
```python
N = 5
A = ["R", "R", "R", "U", "D", "D"]
t = len(A)
trip = []
for i in range(N):
    trip.append(list(range(1,N+1)))

# 위치 초기화
start = [1, 1]
while True:
    # 이동횟수 모두 소진 시 종료한다
    if t == 0:
        break
    for row in A:
        if row == "R":
            if start[1] != 5:
                start[1] += 1
        if row == "L":
            if start[1] != 1:
                start[1] -=1
        if row == "U":
            if start[0] != 1:
                start[0] -= 1
        if row == "D":
            if start [0] != 5:
                start[0] +=1
        t-=1
print(start[0], start[1])
```

#### Sol2 : 좌표 변수 활용하기
> ** 좌표 변수 ? **
좌표가 활용되는 문제에서 많이 쓰이는 방법이다!
- move_types = ["D", "U", "L", "R"]
- dx : [0, 0, -1, 1]
- dy : [1, -1, 0, 0]


```python
N = 5
A = ["R", "R", "R", "U", "D", "D"]
# 위치 초기화
x = 1
y = 1

# 이동 유형 4가지 / 좌표활용
move_types = ["D", "U", "L", "R"]
dx = [0, 0, -1, 1]
dy = [1, -1, 0, 0]

for row in A:
    for i in range(len(move_types)):
        if row == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]
    # 공간을 벗어나는 경우
    if nx<1 or ny<1 or nx>n or ny>n:
        continue
    # 이동 수행하기
    x, y = nx, ny
print(x, y)
```

시간을 측정해보니 확실히 Sol1보다 더 빠른 시간복잡도를 보였다! 이런식의 사고가 정말 절실하구나!

<br>


## 2. 특정 숫자가 포함되는 시각 갯수 구하기
> **완전 탐색**유형
- 정수 N이 주어졌을때 00시00분00초부터 N시 59분 59초까지의 시간 중 "3"이 포함되는 시각의 수를 구하라!
- 예시: N=5 일때 00시00분03초 카운트 / 00시00분05초는 카운트 하지 않는다

<br>

#### Sol1 (완전탐색법) : 시/분/초에 대한 반복문 활용

```python
h = 5

count = 0
# 0부터 h시 까지 범위
for i in range(h+1):
    # 0부터 59분까지 범위
    for m in range(60):
        # 0부터 59초까지 범위
        for s in range(60):
            if "3" in str(i) + str(m) + str(s):
                count += 1
print(count)
```