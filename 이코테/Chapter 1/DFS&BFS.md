드디어! DFS와 BFS의 이론이다.
이전에 인프런으로 공부했을땐 이론보단 **문제풀이**법에 좀더 초점을 맞췄었는데 이론이 많이 부족한거 같아 이코테로 이론을 좀더 다져놓기로했다.! 인프런과 함께 병행하도록 하자.

<br>

***

<br>

# 1. 자료구조 : 스택 & 큐

DFS와 BFS를 제대로 이해하기 위해선 기본 자료구조에 대해 알아야 한다. 기본 자료구조에 속하는 스택과 큐에 대해 알아보도록 하자

> **자료구조 ?**
>자료구조란 '데이터를 표현하고 관리하고 처리하기 위한 구조'를 의미한다. 이에는 두가지 핵심적인 함수로 구성되어 있다.
>- 삽입(Push) : 데이터 삽입
>- 삭제(Pop) : 데이터 삭제
<br>
> 그리고 다음과 같은 개념도 알고 이에 대해 고민해야 한다.
>- 오버플로(Overflow) : 특정한 자료구조가 수용할 수 있는 데이터의 크기를 이미 가득 찬 상태에서 삽입 연산을 수행할 때 발생
>- 언더플로(Underflow) : 특정한 자료구조에 데이터가 전혀 들어있지 않은 상태에서 삭제 연산을 수행하여 데이터가 전혀 없는 상태에서 발생

<br>

## 1) 스택(Stack)

> _like 박스 쌓기_

스택은 **선입후출구조** 혹은 **후입선출구조**라고 한다.

python에서는 스택구조를 사용하기 위해 별도의 라이브러리를 사용하지 않아도 된다. 존재하는 list 형식에서 구현 가능하다.
> **python list의 stack구조**
>- list.append(@) : @을 가장 뒤쪽에 삽입
>- list.pop() : 가장 뒤쪽의 요소를 제거

<br>

## 2) 큐(Queue)

> _like 대기 줄_

python에서 큐구조를 사용하기 위해서는 **deque** 라이브러리를 사용해야 한다. 이 라이브러리는 **collection 모듈**에 있는데 보통의 코딩테스트에서 이의 사용을 허용한다.

```python
from collections import deque

# deque()를 상속받는 변수 queue 지정
queue = deque()

# 큐 예시
queue.append(5)
queue.append(3)
queue.popleft()

print(queue) : deque([3])

# 비교를 위한 스택 예시
stack = []
stack.append(5)
stack.append(3)
stack.pop()
print(stack) : [5]
```

이때 큐구조에서 프린트 된 형태에 주의! 값은 list 형태가 아닌 **deque와 함게 출력된다.** 이를 List로 바꾸려면 **list(queue)로 list자료형으로 변환**해주면 된다.

<br>

# 2. 재귀 함수

> **재귀 함수 ?**
>Recursive Function이라고 하며 **자기 자신을 다시 호출하는 함수**이다.

### Q) 재귀 함수 무한정 호출 가능 ?
결론은 No! 어느 정도 출력하다가 다음과 같은 에러가 발생할 것이다.
```bash
RecursionError: maximum recursion depth exceeded while pickling an object
```
이 말은 **재귀의 최대 깊이를 초과했다**는 말이다.
보통 python interpreter는 호출횟수에 제한이 있는데 이 한계를 벗어난 것. 

따라서 재귀함수를 사용할땐 꼭 **재귀함수의 종료 조건**을 명시해 주어야 한다.

<br>

## 1) 스택과 재귀함수

컴퓨터 내부에서 **재귀 함수의 수행은 스택 자료구조를 이용한다.** 즉, 함수를 계속 호출했을때 가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문이다.

=> 연속해서 호출되는 함수는 메인 메모리의 스택 공간에 적재된다!!

## 2) 재귀함수의 예 : 팩토리얼

> **팩토리얼의 종료 조건**
0!과 1!은 모두 같은 1이다. 따라서 재귀함수를 이용해 팩토리얼 문제를 풀 경우 n이 1이하가 될때 종료하면 된다.

<br>

### Q) 재귀함수 유무에 따른 팩토리얼 풀이법

#### Sol1 : 재귀함수 사용 X

```python
def factorial(n):
    result = 1
    for i in range(1, n+1):
        result *= i
    return result

n = 5 / answer : 120
```

<br>

#### Sol2 : 재귀함수 사용 O

```python
def factorial(n):
    if n<=1:
        return 1
    return n*facotrial(n-1)

n = 5 / answer : 120
```

<br>

### A) 재귀함수를 사용했을때의 장점

**코드가 간결하다!!** 그 이유는 **재귀함수가 수학의 점화식(재귀식)을 그대로 소스코드로 옮겼기 때문이다**

> **점화식**
> 수학에서 점화식은 특정한 함수를 자신보다 더 작은 변수에 대한 함수와의 관계로 포현한 것을 의미한다.
>
> => **다이나믹 프로그래밍**에서 이 개념이 이어지니 인지하고 있기!