# 1463 - Python
https://www.acmicpc.net/problem/1463
![](https://images.velog.io/images/c_hyun403/post/ddc5f0e1-9337-4d6e-918f-5a7071c11ede/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-05%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.41.52.png)![](https://images.velog.io/images/c_hyun403/post/6772fe61-31a1-4799-b015-a2c5eb2f8f6a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-05%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%2011.42.08.png)
조건은 3가지 이다.
>
1. x%3 == 0 이라면 x/3 한다.
2. x%2 == 0 이라면 x/2 한다.
3. 아니면 x-1 한다.

![](https://images.velog.io/images/c_hyun403/post/47051bd3-1451-4eba-a9aa-545d3c1c7b24/1463.png)과정을 그림으로 그려봤다!

**이를 보면 알수 있는것**

1. 계산이 반복된다 (같은 색으로 칠해진 숫자들)
2. 위의 숫자는 바로 아래의 숫자의 경로 +1 이다. (10은 9결과 +1 / 5결과 +1만큼의 순번을 가진다) 이중 하나가 최적 경로이다.

## 점화식
1번의 문제는 memoization을 이용해 해결하도록 하고, 2번을 통해 점화식을 알 수 있다! 정수 n의 최소 경로에 대한 점화식은
>dp[n] = min(dp[n-1], dp[n//2], dp[n//3]) + 1

따라서 문제에 대한 코드로는 다음과 같이 작성하였다.
(내가 작성한 방식은 흔히 말하는 bottom-up 방식 이라고 한다.)
```python
x=int(input()) #정수 x 받기
dp = [0] * 1000001 # x가 1000000까지 이므로 제한 두고 dp 값 초기화 하기 / 1000000번째까지 모든 value가 0으로 지정된다. / dp[1]도 0이다.
# 다이나믹 프로그래밍 진행 (bottom - up 방식)
for i in range(2, x+1):
    # 현재의 수에서 1을 빼는 경우
    dp[i] = dp[i-1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2]+1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3]+1)
print(dp[x])
```

위 코드에 숫자를 하나씩 대입했을 때를 생각해 보았다.(이래야 이해가 빡!! 된다)
먼저 최종적으로 숫자6까지를 구한다고 가정했을때.
```python
for i in range (2, 7)
    #2 실행
    dp[2] = dp[1] + 1 # dp[1] 은 0 이므로 이 값은 1
    if i % 2 == 0:
    dp[2] = min(dp[2], dp[2//2]+1) # min(dp[2], dp[1]+1) = min(1, 0+1) / 결국 dp[2]는 1이다.
    ...
    ...
    #6 실행
    dp[6] = dp[5] + 1 # dp[5]는 3 이므로 이 값은 4
    # 6%2 == 0
    dp[6] = min(dp[6], dp[6//2] +1) # min(dp[6], dp[3]+1) / dp[3]은 1 이므로 이는 min(4, 2) / 따라서 dp[6]은 최솟값인 2로 재설정 된다.
    # 6%3 == 0
    dp[6] = min(dp[6], dp[6//3] +1) # min(dp[6], dp[2]+1) / min(2, 2) / 따라서 최종적으로 dp[6]은 2가 된다.
```
이런식으로 for문을 통해 돌려진 값들은 dp list에 저장되어 보다 빠른 출력이 가능해진다!
<br><br>

# 9095 - Python
https://www.acmicpc.net/problem/9095
![](https://images.velog.io/images/c_hyun403/post/87ed0fb5-d3a6-4ce1-9079-178f6316bc94/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.16.08.png)![](https://images.velog.io/images/c_hyun403/post/398bf804-d08a-4369-8b0f-e290d8dc1a33/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-06%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2012.16.19.png)

위 조건대로 각 숫자를 나타내는 방법에 대해서 5까지 정리해 보았다.
>
- 1 = 1
- 2 = 1+1 / 2
- 3 = 1+1+1 / 2+1 / 1+2 / 3
- 4 = 1+1+1+1 / 2+1+1 / 1+2+1 / 3+1 / 1+1+2 / 2+2 / 1+3
- 5 = 1+1+1+1+1 / 2+1+1+1 / 1+2+1+1 / 3+1+1 / 1+1+2+1 / 2+2+1 / 1+3+1
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1+1+1+2 / 2+1+2 / 1+2+2 / 3+2 /
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1+1+3 / 2+3

규칙성이 보인다.
4의 경우 3에서 나온 값들 뒤에 +1만큼 하였고, 2에서 나온값들 뒤에 +2만큼 하였고, 1에서 나온 값 뒤에 +3만큼 한 경우를 모두 더하였다.!
5의 경우 (4 경우 +1) + (3 경우 +2) + (2 경우 +1) 경우들의 합만큼 나왔다!! (조건이 1, 2, 3만을 더하는 것이므로 4는 합 계산에 사용하지 않앗다.)

## 점화식
따라서 n번째의 경우의 수를 구하려고 하면 n-1 , n-2 , n-3 번째의 경우의 수를 모두 더하면 된다. _(만약 숫자 4까지 활용했으면 n-4번째 경우까지 더해야 했을것이다.)_
>
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

그런데 여기서 주의할 것은 앞선 1463과 달리 초기값을 0으로 설정하면 안된다! 1, 2, 3의 값을 일단 1, 4, 7로 넣어주어야 한다.

내가 처음 짠 코드는 아래와 같다
```python
t = int(input())
for i in range(t):
    n = int(input())
    dp = [1, 2, 4]
    for i in range(3, n):
        dp[i] = dp[i-3] + dp[i-2] + dp[i-1]
    print(dp[n-1])
```
이렇게 하니 **IndexError: list assignment index out of range** 라고 뜬다.
구글링 해보니
list에서는 원소가 없는 상태에서 재배치 할수 없다고 한다.!
즉, 내가 처음 설정한 dp list 값을 0, 1, 2번째 값만 설정했으므로 3번째 값으로 올 dp[i]의 값을 = dp[i-3] + dp[i-2] + dp[i-1]로 설정하지 못한다는 것이다.

이를 해결하기 위해 무작정 원소를 배치시켰다.
```python
t = int(input())
for i in range(t):
    n = int(input())
    dp = [1, 2, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    for i in range(3, n):
        dp[i] = dp[i-3] + dp[i-2] + dp[i-1]
    print(dp[n-1])
````
이렇게하면 제대로 출력된다!

그런데 좀... 지저분하지 않은가?

### 리팩토링
리스트에 원소를 재배치 하지 않고 추가하는 방법을 사용하면 될것 같다.
원소를 추가하는 방법은 insert와 append가 있는데 지금은 append를 사용하였다.
```python
t = int(input()) # test-case 입력하기
for i in range(t): # test-case 횟수만큼 다음의 행동반복된다.
    dp = [1, 2, 4] # dp의 초깃값 설정 #0 = 1, #1 = 2, #2 = 4
    n = int(input()) # 구하고자 하는 순번 입력
    for i in range(3, n): # dp순서가 0번째부터 시작했으므로 n+1이 아닌 n 번째에서 끝나는게 맞다
        dp.append(dp[i-3] + dp[i-2] + dp[i-1]) # dp[i] = dp[i-3] + dp[i-2] + dp[i-1]
    print(dp[n-1]) # dp의 순서가 0번째 부터 시작이므로 n을 입력하여 이에 대항하는 값을 찾으려면 n-1번째 순서가 맞다.
```

들여쓰기 횟수도 같고, 코드 줄도 같지만... 내가 보기엔 이게 더 깔끔할것 같다! 그리고 append 함수까지 활용하는 모습이 보기 좋아보인다😀😃
